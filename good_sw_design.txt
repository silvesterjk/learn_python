Features of Good Design:
1. Reuse code as much as possible.
  - At the low­est level, you reuse class­es: class libraries, con­tain­ers, maybe some class “teams” like con­tain­er/iter­a­tor.
  - Frame­works are at the high­est level. They real­ly try to dis­till your design deci­sions. They iden­ti­fy the key abstrac­tions for solv­ing a prob­lem, rep­re­sent them by class­es and define rela­tion­ships between them.
  - Design pattern could be the middle level.

2. Extensibility:
  - Allow for the code to extend to more features.

| Design Principles

1. Encapsulate what varies:
  - Identify the aspects of the app that changes and the ones that remain the same.
  - Method level: If a method that calculates the orderTotal, that can call getTaxRate method inside to calculate the tax, that way if the tax rate change, we'll only have to touch that.
  - Class level: Sometimes it is probably a good idea to seperate classes based on what it is expected to do. If a class computes all the order details class can handle all the tax related functionality.

2. Program to an interface and not an implementation. 
  - Initially, you might make one class directly dependent on another for collaboration, which is a common starting point.
  - For a more flexible approach, define an interface or abstract class detailing the necessary methods one object needs from another. 
  - Then, make the dependent class rely on this interface instead of the concrete class, allowing for interchangeable implementations.

  Decoupling through Polymorphism and Interfaces: Initially, even with interfaces, the Company class might still be tied to concrete employee classes during object creation. 
  By leveraging polymorphism and an Employee interface, the Company can interact with various employee types uniformly through a doWork() method. 
  However, to truly decouple the Company from knowing about specific employee types during their instantiation, a further step is needed.

  Achieving Full Decoupling with the Factory Method Pattern: To make the Company class fully independent of concrete employee types, the responsibility of creating employee objects is moved to subclasses (e.g., GameDev   Company, Outsourcing Company). 
  This is achieved by declaring a method (like getEmployees()) as abstract in the base Company class, forcing concrete company subclasses to implement their own specific employee creation logic. 
  This approach, known as the Factory Method pattern, allows for the introduction of new employee types or company variations without altering the core Company class, enhancing extensibility and reusability.

  Initial (Tightly Coupled)
  Concrete Class A --> Concrete Class B
  (e.g., Cat --> Sausage)
  (e.g., Company --> Designer, Programmer, Tester)
  
  Improved (Flexible with Interface)
  Concrete Class A --> Interface C <-- Concrete Class B
  (e.g., Cat --> Food <-- Sausage)
  (e.g., Company --> Employee <-- Designer, Programmer, Tester)
  
  Further Decoupling (Factory Method Pattern)
  Abstract Company Class --> Abstract getEmployees() Method
  Concrete Company Subclasses (e.g., GameDev Company, Outsourcing Company) --> Implement getEmployees() to create specific Employee types
  Company Class (primary method) uses getEmployees() (polymorphically) --> Interface Employee --> Concrete Employee Types (e.g., Designer, Programmer, Artist, Tester)

3. 
