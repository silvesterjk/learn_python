Features of Good Design:
1. Reuse code as much as possible.
  - At the low­est level, you reuse class­es: class libraries, con­tain­ers, maybe some class “teams” like con­tain­er/iter­a­tor.
  - Frame­works are at the high­est level. They real­ly try to dis­till your design deci­sions. They iden­ti­fy the key abstrac­tions for solv­ing a prob­lem, rep­re­sent them by class­es and define rela­tion­ships between them.
  - Design pattern could be the middle level.

2. Extensibility:
  - Allow for the code to extend to more features.

| Design Principles

1. Encapsulate what varies:
  - Identify the aspects of the app that changes and the ones that remain the same.
  - Method level: If a method that calculates the orderTotal, that can call getTaxRate method inside to calculate the tax, that way if the tax rate change, we'll only have to touch that.
  - Class level: Sometimes it is probably a good idea to seperate classes based on what it is expected to do. If a class computes all the order details class can handle all the tax related functionality.

2. Program to an interface and not an implementation. 
  - Initially, you might make one class directly dependent on another for collaboration, which is a common starting point.
  - For a more flexible approach, define an interface or abstract class detailing the necessary methods one object needs from another. 
  - Then, make the dependent class rely on this interface instead of the concrete class, allowing for interchangeable implementations.

  Decoupling through Polymorphism and Interfaces: Initially, even with interfaces, the Company class might still be tied to concrete employee classes during object creation. 
  By leveraging polymorphism and an Employee interface, the Company can interact with various employee types uniformly through a doWork() method. 
  However, to truly decouple the Company from knowing about specific employee types during their instantiation, a further step is needed.

  Achieving Full Decoupling with the Factory Method Pattern: To make the Company class fully independent of concrete employee types, the responsibility of creating employee objects is moved to subclasses (e.g., GameDev   Company, Outsourcing Company). 
  This is achieved by declaring a method (like getEmployees()) as abstract in the base Company class, forcing concrete company subclasses to implement their own specific employee creation logic. 
  This approach, known as the Factory Method pattern, allows for the introduction of new employee types or company variations without altering the core Company class, enhancing extensibility and reusability.

  Initial (Tightly Coupled)
  Concrete Class A --> Concrete Class B
  (e.g., Cat --> Sausage)
  (e.g., Company --> Designer, Programmer, Tester)
  
  Improved (Flexible with Interface)
  Concrete Class A --> Interface C <-- Concrete Class B
  (e.g., Cat --> Food <-- Sausage)
  (e.g., Company --> Employee <-- Designer, Programmer, Tester)
  
  Further Decoupling (Factory Method Pattern)
  Abstract Company Class --> Abstract getEmployees() Method
  Concrete Company Subclasses (e.g., GameDev Company, Outsourcing Company) --> Implement getEmployees() to create specific Employee types
  Company Class (primary method) uses getEmployees() (polymorphically) --> Interface Employee --> Concrete Employee Types (e.g., Designer, Programmer, Artist, Tester)

3. Favoring composition over inheritance is a core principle in object-oriented programming that promotes building complex objects by combining simpler ones, rather than inheriting functionality from a parent class.

Key Takeaways

While inheritance ("is a" relationship) seems like a straightforward way to reuse code, it introduces several problems:

  * Rigid Interfaces: A subclass must implement all abstract methods of its superclass, even those it doesn't need.
  * Compatibility Risks: When overriding methods, you must ensure the new behavior is consistent with the parent's, as subclass objects can be used anywhere superclass objects are expected.
  * Broken Encapsulation: Inheritance exposes the internal workings of the superclass to the subclass, creating a tight coupling.
  * High Coupling: Changes in the superclass can easily break the functionality of its subclasses.
  * Hierarchy Explosion: Attempting to model multiple independent attributes (e.g., a car that can be electric or gas, and also a sedan or SUV) with inheritance leads to a complex and bloated class structure.

Composition ("has a" relationship) offers a more flexible alternative. Instead of a class inheriting behaviors, it holds an instance of another class that provides the required functionality. This approach avoids the pitfalls of inheritance by promoting flexibility and decoupling components.

-----

Pseudocode Example

Here's an example illustrating the shift from a rigid inheritance model to a flexible composition model for different types of employees.

#Inheritance Approach (Less Flexible)

With inheritance, if we want to add a new type of work behavior, like `ManagesProjects`, we would have to create more specific subclasses like `ManagingProgrammer`, leading to a complex hierarchy.

```python
# --- Inheritance Example ---

class Employee:
    def __init__(self, name):
        self.name = name

    def work(self):
        # Generic work behavior
        print(f"{self.name} is working.")

# Subclasses inherit from Employee
class Programmer(Employee):
    def work(self):
        print(f"{self.name} is writing code.")

class Salesperson(Employee):
    def work(self):
        print(f"{self.name} is selling products.")

# Usage
programmer = Programmer("Alice")
programmer.work()  # Output: Alice is writing code.

salesperson = Salesperson("Bob")
salesperson.work() # Output: Bob is selling products.
```

#Composition Approach (More Flexible)

With composition, an `Employee` has a work behavior. We can easily assign or change this behavior without altering the `Employee` class or creating new subclasses.

```python
# --- Composition Example ---

# Define behavior classes
class CodingBehavior:
    def execute(self):
        return "writing code."

class SellingBehavior:
    def execute(self):
        return "selling products."

class ProjectManagementBehavior:
    def execute(self):
        return "managing projects."

# The Employee class is now composed with a work behavior
class Employee:
    def __init__(self, name, work_behavior):
        self.name = name
        # The Employee "has a" work behavior
        self.work_behavior = work_behavior

    def work(self):
        action = self.work_behavior.execute()
        print(f"{self.name} is {action}")

# Usage
# Create employees by "composing" them with different behaviors
programmer = Employee("Alice", CodingBehavior())
programmer.work()  # Output: Alice is writing code.

salesperson = Employee("Bob", SellingBehavior())
salesperson.work() # Output: Bob is selling products.

# We can easily create a new type of role without a new subclass
manager = Employee("Charlie", ProjectManagementBehavior())
manager.work() # Output: Charlie is managing projects.
```
